{"version":3,"sources":["../../src/auth/index.js"],"names":["jwt","jsonwebtoken","TOKEN_KEY","process","env","SALT_ROUNDS","parseInt","AuthController","req","res","next","token","headers","authorization","split","data","verify","locals","user","error","status","send","json","payload","sign","exp","Math","floor","Date","getTime","password","bcrypt","compare","password_digest","message","hash"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;;;;;;;;;AACA,IAAMA,GAAG,GAAGC,wBAAZ;AACA,IAAMC,SAAS,GAAGC,OAAO,CAACC,GAAR,CAAYF,SAA9B;AACA,IAAMG,WAAW,GAAGC,QAAQ,CAACH,OAAO,CAACC,GAAR,CAAYC,WAAb,CAA5B;;IAEqBE,c;;;;;;;;;iCACAC,G,EAAKC,G,EAAKC,I;;;;;;AAC3B,kBAAI;AACIC,gBAAAA,KADJ,GACYH,GAAG,CAACI,OAAJ,CAAYC,aAAZ,CAA0BC,KAA1B,CAAgC,GAAhC,EAAqC,CAArC,CADZ;AAEIC,gBAAAA,IAFJ,GAEWf,GAAG,CAACgB,MAAJ,CAAWL,KAAX,EAAkBT,SAAlB,CAFX;AAGFO,gBAAAA,GAAG,CAACQ,MAAJ,CAAWC,IAAX,GAAkBH,IAAlB,CAHE,CAIF;;AACAL,gBAAAA,IAAI;AACL,eAND,CAME,OAAOS,KAAP,EAAc;AACdV,gBAAAA,GAAG,CAACW,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEF,kBAAAA,KAAK,EAAE;AAAT,iBAArB;AACD;;;;;;;;;;;gCAGeX,G,EAAKC,G;;;;;;AACrB,kBAAI;AACIE,gBAAAA,KADJ,GACYH,GAAG,CAACI,OAAJ,CAAYC,aAAZ,CAA0BC,KAA1B,CAAgC,GAAhC,EAAqC,CAArC,CADZ;AAEII,gBAAAA,IAFJ,GAEWlB,GAAG,CAACgB,MAAJ,CAAWL,KAAX,EAAkBT,SAAlB,CAFX;AAGFO,gBAAAA,GAAG,CAACa,IAAJ,CAASJ,IAAT;AACD,eAJD,CAIE,OAAOC,KAAP,EAAc;AACdV,gBAAAA,GAAG,CAACW,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEF,kBAAAA,KAAK,EAAE;AAAT,iBAArB;AACD;;;;;;;;;;;8BAGOI,O,EAAS;AACjB,UAAMZ,KAAK,GAAGX,GAAG,CAACwB,IAAJ,CACZ;AAAED,QAAAA,OAAO,EAAPA,OAAF;AAAWE,QAAAA,GAAG,EAAEC,IAAI,CAACC,KAAL,CAAW,IAAIC,IAAJ,GAAWC,OAAX,KAAuB,IAAlC,IAA0C,KAAK;AAA/D,OADY,EAEZ3B,SAFY,CAAd;AAIA,aAAOS,KAAP;AACD;;;mCAEoBO,I,EAAMY,Q,EAAUrB,G;;;;;;;8CAEpBsB,mBAAOC,OAAP,CAAeF,QAAf,EAAyBZ,IAAI,CAACe,eAA9B,C;;;;;;;;AAEbxB,cAAAA,GAAG,CAACW,MAAJ,CAAW,GAAX,EAAgBE,IAAhB,CAAqB;AAAEH,gBAAAA,KAAK,EAAE,aAAMe;AAAf,eAArB;;;;;;;;;;;iCAIeJ,Q,EAAUrB,G;;;;;;;8CAEZsB,mBAAOI,IAAP,CAAYL,QAAZ,EAAsBzB,WAAtB,C;;;;;;;;AAEbI,cAAAA,GAAG,CAACW,MAAJ,CAAW,GAAX,EAAgBE,IAAhB,CAAqB;AAAEH,gBAAAA,KAAK,EAAE,aAAMe;AAAf,eAArB","sourcesContent":["import 'dotenv/config'\nimport { compare } from '../services'\nimport jsonwebtoken from 'jsonwebtoken'\nimport bcrypt from 'bcrypt'\nconst jwt = jsonwebtoken\nconst TOKEN_KEY = process.env.TOKEN_KEY\nconst SALT_ROUNDS = parseInt(process.env.SALT_ROUNDS)\n\nexport default class AuthController {\n  async Authenticate(req, res, next) {\n    try {\n      const token = req.headers.authorization.split(' ')[1]\n      const data = jwt.verify(token, TOKEN_KEY)\n      res.locals.user = data\n      // if (compare(req))\n      next()\n    } catch (error) {\n      res.status(403).send({ error: 'Unauthorized' })\n    }\n  }\n\n  async VerifyToken(req, res) {\n    try {\n      const token = req.headers.authorization.split(' ')[1]\n      const user = jwt.verify(token, TOKEN_KEY)\n      res.json(user)\n    } catch (error) {\n      res.status(403).send({ error: 'Unauthorized' })\n    }\n  }\n\n  SignToken(payload) {\n    const token = jwt.sign(\n      { payload, exp: Math.floor(new Date().getTime() / 1000) + 42 * 3600 },\n      TOKEN_KEY\n    )\n    return token\n  }\n\n  async VerifyPassword(user, password, res) {\n    try {\n      return await bcrypt.compare(password, user.password_digest)\n    } catch (error) {\n      res.status(500).json({ error: error.message })\n    }\n  }\n\n  async HashPassword(password, res) {\n    try {\n      return await bcrypt.hash(password, SALT_ROUNDS)\n    } catch (error) {\n      res.status(500).json({ error: error.message })\n    }\n  }\n}\n"],"file":"index.js"}